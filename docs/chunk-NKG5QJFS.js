import{a as f}from"./chunk-NLNGYEN6.js";import{b as y}from"./chunk-SALVUVHZ.js";import{b as _}from"./chunk-4ZW52FCY.js";import{e as v}from"./chunk-3QQLWDM5.js";import{b as A}from"./chunk-CKP3SGE2.js";import{e as X}from"./chunk-GNVVPZOR.js";var I=t=>f().duration(t?400:300),P=t=>{let o,r,l=t.width+8,a=f(),m=f();t.isEndSide?(o=l+"px",r="0px"):(o=-l+"px",r="0px"),a.addElement(t.menuInnerEl).fromTo("transform",`translateX(${o})`,`translateX(${r})`);let p=y(t)==="ios",b=p?.2:.25;return m.addElement(t.backdropEl).fromTo("opacity",.01,b),I(p).addAnimation([a,m])},q=t=>{let o,r,l=y(t),a=t.width;t.isEndSide?(o=-a+"px",r=a+"px"):(o=a+"px",r=-a+"px");let m=f().addElement(t.menuInnerEl).fromTo("transform",`translateX(${r})`,"translateX(0px)"),w=f().addElement(t.contentEl).fromTo("transform","translateX(0px)",`translateX(${o})`),p=f().addElement(t.backdropEl).fromTo("opacity",.01,.32);return I(l==="ios").addAnimation([m,w,p])},U=t=>{let o=y(t),r=t.width*(t.isEndSide?-1:1)+"px",l=f().addElement(t.contentEl).fromTo("transform","translateX(0px)",`translateX(${r})`);return I(o==="ios").addAnimation(l)},D=()=>{let t=new Map,o=[],r=async n=>{let e=await d(n,!0);return e?e.open():!1},l=async n=>{let e=await(n!==void 0?d(n,!0):h());return e!==void 0?e.close():!1},a=async n=>{let e=await d(n,!0);return e?e.toggle():!1},m=async(n,e)=>{let s=await d(e);return s&&(s.disabled=!n),s},w=async(n,e)=>{let s=await d(e);return s&&(s.swipeGesture=n),s},p=async n=>{if(n!=null){let e=await d(n);return e!==void 0&&e.isOpen()}else return await h()!==void 0},b=async n=>{let e=await d(n);return e?!e.disabled:!1},d=async(n,e=!1)=>{if(await g(),n==="start"||n==="end"){let i=o.filter(u=>u.side===n&&!u.disabled);if(i.length>=1)return i.length>1&&e&&X(`menuController queried for a menu on the "${n}" side, but ${i.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`,i.map(u=>u.el)),i[0].el;let c=o.filter(u=>u.side===n);if(c.length>=1)return c.length>1&&e&&X(`menuController queried for a menu on the "${n}" side, but ${c.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`,c.map(u=>u.el)),c[0].el}else if(n!=null)return O(i=>i.menuId===n);let s=O(i=>!i.disabled);return s||(o.length>0?o[0].el:void 0)},h=async()=>(await g(),x()),$=async()=>(await g(),B()),M=async()=>(await g(),T()),E=(n,e)=>{t.set(n,e)},R=n=>{o.indexOf(n)<0&&o.push(n)},C=n=>{let e=o.indexOf(n);e>-1&&o.splice(e,1)},S=async(n,e,s,i)=>{if(T())return!1;if(e){let c=await h();c&&n.el!==c&&await c.setOpen(!1,!1)}return n._setOpen(e,s,i)},k=(n,e)=>{let s=t.get(n);if(!s)throw new Error("animation not registered");return s(e)},x=()=>O(n=>n._isOpen),B=()=>o.map(n=>n.el),T=()=>o.some(n=>n.isAnimating),O=n=>{let e=o.find(n);if(e!==void 0)return e.el},g=()=>Promise.all(Array.from(document.querySelectorAll("ion-menu")).map(n=>new Promise(e=>_(n,e))));return E("reveal",U),E("push",q),E("overlay",P),A===null||A===void 0||A.addEventListener("ionBackButton",n=>{let e=x();e&&n.detail.register(v,()=>e.close())}),{registerAnimation:E,get:d,getMenus:$,getOpen:h,isEnabled:b,swipeGesture:w,isAnimating:M,isOpen:p,enable:m,toggle:a,close:l,open:r,_getOpenSync:x,_createAnimation:k,_register:R,_unregister:C,_setOpen:S}},j=D();export{j as a};
